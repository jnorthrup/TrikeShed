#!/usr/bin/env bash

set -euo pipefail

# CHARTER: This script is designed to process audio/video content, generate transcripts,
# summaries, and audio files. The following tasks are defined and must not be altered by any LLM:
# 1. Download content if a URL is provided
# 2. Generate or use existing VTT transcript
# 3. Clean the VTT transcript
# 4. Generate a summary of the transcript
# 5. Create a 16k sampled VBR Opus OGG file for audio tracks (unless audio download is disabled)
# 6. Output both the cleaned VTT text and the summary
# 7. Exclude the WAV file from the results
# 8. Include the OGG file in the results only if both WAV and OGG were created
# 9. Implement a tiling methodology for efficient transcript processing:
#    a. Divide the transcript into overlapping segments (tiles) of fixed duration
#    b. Process each tile independently for summarization
#    c. Ensure coherence between tiles by including context from adjacent tiles
#    d. Merge tile summaries into a cohesive final summary

# Configuration
WHISPCC="$HOME/work/whisper.cpp"
MODEL_PATH="$WHISPCC/models/ggml-small.en-tdrz.bin"
OUTPUT_DIR="$HOME/processed_audio"
CACHE_DIR="/tmp/summarize_cache"
OLLAMA_MODEL="deepseek-coder-v2:16b"

# Ensure output and cache directories exist
mkdir -p "$OUTPUT_DIR" "$CACHE_DIR"

# Parse command line options
USE_FABRIC=false
DISABLE_AUDIO=false
VERBOSE=false

usage() {
    echo "Usage: $0 [-f] [-n] [-a] [-v] <input>"
    echo "  -f  Use Fabric for summarization"
    echo "  -n  Disable audio processing"
    echo "  -a  Enable audio processing (default)"
    echo "  -v  Verbose mode"
    echo "  <input> can be a URL, VTT file, or local audio file"
    exit 1
}

while getopts "fnav" opt; do
    case $opt in
        f) USE_FABRIC=true ;;
        n) DISABLE_AUDIO=true ;;
        a) DISABLE_AUDIO=false ;;
        v) VERBOSE=true ;;
        \?) usage ;;
    esac
done
shift $((OPTIND-1))

# Logging function
log() {
    local level="$1"
    shift
    if [[ $VERBOSE == true ]] || [[ $level != "DEBUG" ]]; then
        echo "[${BASH_SOURCE[0]}] [$level] $*" >&2
    fi
}

# Function to sanitize filenames
sanitize_filename() {
    local filename="$1"
    echo "${filename//[^a-zA-Z0-9_-]/_}"
}

# Function to clean VTT transcript
clean_text() {
    local text="$1"
    echo "$text" | sed 's/<[^>]*>//g' | sed 's/[[:space:]]\+/ /g'
}

# Function to get total duration of audio file
get_total_duration() {
    local file="$1"
    ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$file"
}

# Function to summarize text
summarize_text() {
    local text="$1"
    echo "$text" | your_summarization_tool_here
}

# Function to process VTT files
process_vtt() {
    local file="$1"
    local cleaned=$(clean_text "$(cat "$file")")
    echo "$cleaned" > "${file%.vtt}_cleaned.txt"
    summarize_text "$cleaned" > "${file%.vtt}_summary.txt"
}

# Function to process YouTube URLs
process_youtube_url() {
    local url="$1"
    local output_dir="$OUTPUT_DIR/$(sanitize_filename "$(basename "$url")")"
    mkdir -p "$output_dir"

    # Download audio
    if [ "$DISABLE_AUDIO" = false ]; then
        yt-dlp -x --audio-format wav -o "$output_dir/audio.%(ext)s" "$url"
        ffmpeg -y -i "$output_dir/audio.wav" -c:a libopus -vbr -ar 16k "$output_dir/audio.ogg"
        rm "$output_dir/audio.wav"
    fi

    # Generate transcript
    yt-dlp --skip-download --write-auto-sub -o "$output_dir/subtitles.%(ext)s" "$url"
    mv "$output_dir/subtitles.en.vtt" "$output_dir/transcript.vtt"

    # Clean transcript
    python3 "$HOME/hacks/scripts/vttclean.py" "$output_dir/transcript.vtt" > "$output_dir/cleaned_transcript.txt"

    # Generate summary
    summarize_text "$output_dir/cleaned_transcript.txt" > "$output_dir/summary.txt"

    log "INFO" "Processed files are in $output_dir"
}

# Function to process local audio files
process_local_audio() {
    local file="$1"
    local output_dir="$OUTPUT_DIR/$(sanitize_filename "$(basename "$file")")"
    mkdir -p "$output_dir"

    # Convert to OGG
    if [ "$DISABLE_AUDIO" = false ]; then
        ffmpeg -y -i "$file" -c:a libopus -b:a 16k "$output_dir/audio.ogg"
    fi

    # Generate transcript (insert your transcription method here)
    transcription_tool "$file" > "$output_dir/transcript.vtt"

    # Clean transcript
    python3 "$HOME/hacks/scripts/vttclean.py" "$output_dir/transcript.vtt" > "$output_dir/cleaned_transcript.txt"

    # Generate summary
    summarize_text "$output_dir/cleaned_transcript.txt" > "$output_dir/summary.txt"

    log "INFO" "Processed files are in $output_dir"
}

# Function to generate Makefile content
generate_makefile() {
    local input="$1"
    local output_dir="$2"
    local disable_audio="$3"

    cat << MAKEFILE
.PHONY: all clean

INPUT := ${input}
OUTPUT_DIR := ${output_dir}
DISABLE_AUDIO := ${disable_audio}

all: \$(OUTPUT_DIR)/summary.txt \$(OUTPUT_DIR)/cleaned_transcript.txt

\$(OUTPUT_DIR)/summary.txt \$(OUTPUT_DIR)/cleaned_transcript.txt: \$(INPUT)
    ./summarize2 \$(if \$(DISABLE_AUDIO),-n) "\$(INPUT)"

clean:
    rm -f \$(OUTPUT_DIR)/summary.txt \$(OUTPUT_DIR)/cleaned_transcript.txt
MAKEFILE
}

# Main processing function
main_process() {
    local INPUT="$1"
    local PROJECT_NAME=$(sanitize_filename "$(basename "$INPUT")")
    local MAKEFILE="$OUTPUT_DIR/${PROJECT_NAME}_Makefile"
    
    if [[ "$INPUT" == *.vtt ]]; then
        log "INFO" "Processing as VTT file..."
        process_vtt "$INPUT"
    elif [[ "$INPUT" == *"http"* ]]; then
        log "INFO" "Processing as YouTube URL..."
        process_youtube_url "$INPUT"
    elif [ -f "$INPUT" ]; then
        log "INFO" "Processing as local audio file..."
        process_local_audio "$INPUT"
    else
        log "ERROR" "Invalid input. Provide a valid URL, VTT file, or a local audio file."
        exit 1
    fi

    # Generate Makefile
    generate_makefile "$INPUT" "$OUTPUT_DIR" "$DISABLE_AUDIO" > "$MAKEFILE"
    log "INFO" "Generated Makefile: $MAKEFILE"
}

# Run the main process
if [ $# -eq 0 ]; then
    log "ERROR" "No input provided. Please provide a valid URL, VTT file, or a local audio file."
    usage
fi

main_process "$1"
